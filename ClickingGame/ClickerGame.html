<!DOCTYPE html>
<link rel="stylesheet" href="ClickerGame.css">
<body>
	<div id= 'div1'>
		<h5 id="counter"> Number of Rectangles: 0 </h3>
		<br>
		<h2> Preview: </h2>
		<h5 id="RectanglesWidth"> </h5>
		<h5 id="RectanglesHeight"> </h5>
		<br>
		<p> Use arrow keys to change size <p>

	</div>
</body>

<canvas> </canvas>

<script> 
	//Current issue with code: code looks ugly with everything only referencing the rects object created rather than a general one
	var cx = document.querySelector("canvas").getContext("2d");
	cx.canvas.width=window.innerWidth;
	cx.canvas.height=window.innerHeight;

	var rectW = 20;
	var rectH = 20;
	document.getElementById("RectanglesWidth").innerHTML = "Rectangles's width: " + rectW;
	document.getElementById("RectanglesHeight").innerHTML = "Rectangle's height: " + rectH;

	class Rectangles {
		constructor () {
			this.arr = [];
		}
		addRectangle (newRect) {
			this.arr.push(newRect);
		}
		spawnRectangles() {
			for (let i = 0; i < this.arr.length; i++) {
				cx.fillRect(this.arr[i].posX, this.arr[i].posY, this.arr[i].width,
					this.arr[i].height);
			}
		}
		
		naturalMovement() {
			for (let i = 0; i < this.arr.length; i++) {
				this.arr[i].gravity(this.arr);
			}
		}
		remove(other) {
			for (let i = 0; i < this.arr.length; i++) {
				if (this.arr[i].equals(other)) {
					this.arr.splice(i, 1);
				}
			}
		}
	}

	class Rectangle {
		constructor (posX, posY, width, height) {
			this.posX = posX;
			this.posY = posY;
			this.width = width;
			this.height = height;
		}
		drawRectangle() {
			cx.globalAlpha = 0.5;
			cx.fillRect(this.posX, this.posY, this.width,
					this.height);
			cx.globalAlpha = 1;
		}

		equals (other) {
			return (this.posX == other.posX && this.posY == other.posY &&
				this.width == other.width && this.height == other.height);
		}

		//countsItself is for if you want the collission to count for itself
		collides(countsItself) { //Have to account for clicking outside the area but still builds into it
			for (let i = 0; i < rects.arr.length; i++) {
				if ((this.posX >= rects.arr[i].posX-(rects.arr[i].width)) && 
					(this.posX <= (rects.arr[i].posX+(rects.arr[i].width))) &&
					(this.posY >= rects.arr[i].posY-(rects.arr[i].height)) && 
					(this.posY <= (rects.arr[i].posY+(rects.arr[i].height))) &&
					(countsItself || (!countsItself && !this.equals(rects.arr[i])))
					) {
				aa	
				return true;
			}
		}//console.log("a");
		return false;
	}

	gravity () {
		//console.log( !this.collides(false));
		if ( !this.collides(false) && (this.posY+this.height < cx.canvas.height)) {
			/* console.log(cx.canvas.height+ "  "+ (this.posY+this.height) +"    " +(cx.canvas.height-this.height)); */
			this.posY += 2;
		}
			/*if ((!this.collides(otherBoxes)) && this.posY < cx.canvas.height-this.height) {
				this.posY += 2;
				var myReq =  window.requestAnimationFrame(this.gravity(otherBoxes).bind(this));
			}
			else {
				cancelAnimationFrame(myReq);
			} */
		}
	}

	class Monster extends Rectangle {
		constructor (posX, posY, width, height) {
			super(posX, posY, width, height);
		}
		move () {
			if ((this.posX <= 0 && dirAdd == -speed) ||
				(this.posX >= cx.canvas.width && dirAdd == speed))  {
				dirAdd = -dirAdd;
		}
		this.posX += dirAdd;
	}
	drawMonster() {
		if (this.collides(rects) ) {
			rects.remove(this);
		}
		cx.fillRect(this.posX, this.posY, this.width, this.height);
	}
}

var speed = 5;
var dirAdd = speed; //initially moves right
document.addEventListener('click', (e) => {
	document.getElementById('counter').innerHTML = "Number of Rectangles: "+ (rects.arr.length+1);
	let newRect = new Rectangle(e.clientX, e.clientY-rectH,rectW,rectH);
	console.log(e.clientX + " " + e.clientY);
	console.log(newRect.collides(true));
	if (!newRect.collides(true)) {
		rects.addRectangle(newRect);
	}
});

document.addEventListener('keydown', keyEvent);


var sizeScale = 5;
function keyEvent (e) {
	let keyCode = e.keyCode;
	if (keyCode == 39 ) { //keyright, increases size
		rectW+=sizeScale;
		document.getElementById("RectanglesWidth").innerHTML = "Rectangles's width: " + rectW;
	}
	else if (keyCode == 37 && rectW > sizeScale) { //keyleft, decreases size
		rectW -=sizeScale;
		document.getElementById("RectanglesWidth").innerHTML = "Rectangle's width: " + rectW;
	}
	else if (keyCode == 40 ) { //keydown, increases size
		rectH += sizeScale;
		document.getElementById("RectanglesHeight").innerHTML = "Rectangle's height: " + rectH;
	}
	else if (keyCode == 38 && rectH > sizeScale) { //keydown, decreases size
		rectH -= sizeScale
		document.getElementById("RectanglesHeight").innerHTML = "Rectangle's height: " + rectH;
	}
}

function drawPreviewRect() {
	var rectPreview = new Rectangle(100,100, rectW, rectH);
	rectPreview.drawRectangle();
}

function draw() {
	cx.clearRect(0,0, cx.canvas.width, cx.canvas.height);
	rects.naturalMovement();
	rects.spawnRectangles();
	drawPreviewRect();
	monster1.drawMonster();
	monster1.move();
	requestAnimationFrame(draw);
}

	/* var monster1 = {
		width : 50,
		height : 50,
		posX : cx.canvas.width/2,
		posY : function () {return cx.canvas.height-this.height;},
		properties : new Monster(this.posX, this.posY, this.width, this.height)
	} */

	var rects = new Rectangles(); 
	var monster1 = new Monster(cx.canvas.width/2, cx.canvas.height-50,50, 50  );
	draw();

</script>

